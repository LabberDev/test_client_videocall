<!DOCTYPE html>
<html lang="it" data-theme="dark">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Videocall • Meet‑style UI (Enhanced)</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
  <style>
    /* =========================
   THEME TOKENS
   ========================= */
    :root {
      --bg: #0b0f14;
      --surface: #11161c;
      --surface-2: #161d25;
      --surface-3: #202833;
      --text: #e7eef7;
      --text-dim: #b7c2cf;
      --primary: black;
      --danger: #ff5c7a;
      --ok: #3ddc97;
      --warn: #ffce5c;
      --radius: 16px;
      --shadow-sm: 0 2px 10px rgba(0, 0, 0, .25);
      --shadow: 0 8px 28px rgba(0, 0, 0, .35);
      --ring: 0 0 0 2px rgba(92, 157, 255, .45);
      --glass: rgba(255, 255, 255, .06);
      --gap: 12px;
      --tile-aspect: 16 / 9;
    }

    /* light (auto) */
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f8fb;
        --surface: #ffffff;
        --surface-2: #f4f7fb;
        --surface-3: #e9eef6;
        --text: #0f1720;
        --text-dim: #425269;
        --primary: #336fff;
        --danger: #e53955;
        --ok: #16a379;
        --warn: #f59e0b;
        --glass: rgba(15, 23, 32, .06);
        --shadow: 0 8px 28px rgba(15, 23, 32, .12);
      }
    }

    /* light (forzato) */
    [data-theme="light"] {
      --bg: #f6f8fb;
      --surface: #ffffff;
      --surface-2: #f4f7fb;
      --surface-3: #e9eef6;
      --text: #0f1720;
      --text-dim: #425269;
      --primary: #336fff;
      --danger: #e53955;
      --ok: #16a379;
      --warn: #f59e0b;
      --glass: rgba(15, 23, 32, .06);
      --shadow: 0 8px 28px rgba(15, 23, 32, .12);
    }

    /* =========================
   RESET / BASE
   ========================= */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background:
        radial-gradient(1200px 800px at 80% -10%, rgba(92, 157, 255, .12), transparent 40%),
        radial-gradient(1000px 700px at 10% 110%, rgba(61, 220, 151, .10), transparent 40%),
        var(--bg);
      color: var(--text);
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      line-height: 1.5;
      letter-spacing: .2px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    button,
    input,
    select {
      font: inherit;
      color: inherit;
    }

    /* =========================
   APP LAYOUT
   ========================= */
    .app {
      min-height: 100svh;
      background-color: white;
    }

    /* Top App Bar */
    .topbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px clamp(12px, 3vw, 24px);
      background: linear-gradient(180deg, color-mix(in oklab, var(--surface), transparent 25%), transparent);
      position: sticky;
      top: 0;
      z-index: 30;
      backdrop-filter: blur(10px);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 800;
      letter-spacing: .2px;
    }

    .brand .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--ok);
      box-shadow: 0 0 0 6px color-mix(in oklab, var(--ok), transparent 80%);
    }

    .brand .name {
      opacity: .95;
    }

    .spacer {
      flex: 1;
    }

    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--surface-2);
      border: 1px solid var(--glass);
      box-shadow: var(--shadow-sm);
    }

    /* Main */
    .main {
      padding: var(--gap);
      width: 100vw;
    }

    .panel {
      background: transparent;
      border-radius: var(--radius);
      min-height: 0;
      width: auto;
      margin-inline: auto;
    }

    /* Stage: responsive video grid */
    .stage {
      position: relative;
      padding: var(--gap);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--gap);
    }

    .tile {
      position: relative;
      border-radius: clamp(10px, calc(var(--radius) - 6px), 18px);
      overflow: hidden;
      background: #000;
      isolation: isolate;
      min-height: 220px;
      width: 100%;
      aspect-ratio: var(--tile-aspect);
      outline: none;
    }

    .tile::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, transparent, rgba(0, 0, 0, .35) 75%);
      pointer-events: none;
    }

    .tile:focus-visible {
      box-shadow: var(--ring);
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      background: #000;
    }

    .mirror {
      transform: scaleX(-1);
    }

    /* Live badges */
    .badge {
      position: absolute;
      left: 12px;
      bottom: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .30);
      color: #fff;
      font-size: .9rem;
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: var(--shadow-sm);
    }

    .muted-indicator {
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: rgba(0, 0, 0, .48);
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: grid;
      place-items: center;
      border: 1px solid rgba(255, 255, 255, .1);
      box-shadow: var(--shadow-sm);
    }

    /* Active speaker */
    .tile[data-speaking="true"] {
      box-shadow:
        0 0 0 2px color-mix(in oklab, var(--ok), white 15%),
        0 0 0 8px color-mix(in oklab, var(--ok), transparent 85%),
        var(--shadow);
    }

    /* Side panel */
    .side {
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .side header {
      padding: 12px 14px;
      border-bottom: 1px solid var(--glass);
      font-weight: 700;
    }

    .side .content {
      padding: 12px;
      overflow: auto;
      color: var(--text-dim);
    }

    .kv {
      display: grid;
      gap: 6px;
    }

    .kv label {
      color: var(--text-dim);
      font-size: .9rem;
    }

    /* Bottom Controls */
    .controls {
      position: sticky;
      bottom: 0;
      padding: max(8px, env(safe-area-inset-bottom));
      display: flex;
      justify-content: center;
      gap: 10px;
      background: linear-gradient(0deg, color-mix(in oklab, var(--surface), transparent 15%), transparent);
      z-index: 20;
    }

    .pill {
      display: flex;
      gap: 8px;
      padding: 10px 15px;
      background: color-mix(in oklab, var(--surface), #000 8%);
      border-radius: 999px;
      box-shadow: var(--shadow);
      border: 1px solid var(--glass);
      backdrop-filter: blur(8px);
    }

    .ctrl-btn {
      --size: 52px;
      width: var(--size);
      height: var(--size);
      border-radius: 999px;
      border: 1px solid var(--glass);
      background: var(--surface-2);
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
    }

    .ctrl-btn:hover {
      box-shadow: var(--ring);
    }

    .ctrl-btn:active {
      transform: scale(.97);
    }

    .ctrl-btn[aria-pressed="true"] {
      box-shadow: var(--ring);
    }

    .ctrl-btn.danger {
      background: var(--danger);
      border-color: rgba(0, 0, 0, .15);
      color: #fff;
    }

    .ctrl-btn .material-symbols-rounded {
      font-variation-settings: 'FILL' 1;
    }

    /* =========================
   PREJOIN (modal + preview)
   ========================= */
    .prejoin-backdrop {
      position: fixed;
      inset: 0;
      width: 100%;
      background: rgba(0, 0, 0, .6);
      backdrop-filter: blur(16px);
      display: grid;
      place-items: center;
      z-index: 50;
    }

    .prejoin {
      width: min(980px, 96vw);
      max-height: 92svh;
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: grid;
      gap: 0;
      border: 1px solid var(--glass);
      grid-template-columns: 1fr 360px;
      /* desktop default */
    }

    .prejoin .preview {
      margin: 0;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .02), transparent);
      display: grid;
      place-items: center;
    }

    .preview .tile,
    .prejoin .preview .tile {
      position: relative;
      width: 100%;
      max-width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
      /* desktop default */
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .preview :where(#prejoinPreview) {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
    }

    /* Form (right column) */
    .prejoin .form {
      padding: clamp(16px, 2.5vw, 22px);
      display: grid;
      gap: 14px;
      align-content: center;
      justify-items: center;
      text-align: center;
    }

    .prejoin .form .form-title {
      margin: 0 0 8px;
      font-size: 30px;
      font-weight: 800;
      color: var(--text);
    }

    .prejoin-mobile-header {
      display: none;
      padding: 10px;
      width: 100%;
      font-size: 25px;
      font-weight: 800;
      text-align: center;
      color: var(--text);
    }

    /* Overlay controls INSIDE preview */
    /* valido per anteprima e in-call */
    .tile .overlay {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    /* =========================
   FORM ELEMENTS & BUTTONS
   ========================= */
    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      color: var(--text-dim);
      font-size: .9rem;
    }

    .input,
    .select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 0 solid var(--glass);
      background: var(--surface-2);
      color: var(--text);
    }

    .btn-primary {
      padding: 12px 20px;
      margin-inline: auto;
      background: transparent;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      font-weight: 800;
      letter-spacing: .2px;
      box-shadow: 0 8px 24px color-mix(in oklab, black, transparent 50%);
      transition: transform .06s ease, box-shadow .2s ease;
      backdrop-filter: blur(6px);
    }

    .btn-primary:hover {
      box-shadow: 0 10px 30px color-mix(in oklab, black, transparent 68%);
    }

    .btn-primary:active {
      transform: translateY(1px);
    }

    .btn-secondary {
      padding: 10px 12px;
      background: var(--surface-2);
      border: 1px solid var(--glass);
      color: var(--text);
      border-radius: 10px;
      cursor: pointer;
    }

    .hstack {
      display: flex;
      gap: 8px;
      align-items: center;
      text-align: center;
      margin-bottom: 10px;
    }

    /* =========================
   SPLIT BUTTON (base + overlay)
   ========================= */
    .split {
      height: 44px;
      display: inline-flex;
      align-items: center;
      gap: 0;
      width: auto;
      margin-inline: auto;
      margin: auto;
      border-radius: 999px;
      overflow: hidden;
      box-shadow: var(--shadow);
      border: 1px solid #b6b6b9;
      border-right: none;
      background: var(--surface-2);
      position: relative;
    }

    .btn-split {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 44px;
      padding: 0 14px;
      background: transparent;
      border: 0;
      color: var(--text);
      cursor: pointer;
      transition: filter .2s ease;
      line-height: 0;
    }

    .btn-split:hover {
      filter: brightness(1.05);
    }

    .btn-split:focus-visible {
      outline: none;
      box-shadow: var(--ring);
      border-radius: 10px;
    }

    .btn-split .material-symbols-rounded {
      line-height: 1;
      display: inline-block;
    }

    .split-right {
      border-radius: 25px;
      border: 1px solid #b6b6b9;
    }

    .split-right[aria-pressed="false"] {
      opacity: .85;
      background-color: #d36363;
      border: 1px solid #b64b4b;
    }

    /* riflette lo stato anche sul sinistro */
    .split:has(.split-right[aria-pressed="false"]) {
      background-color: #e97b7bc6;
      border: 1px solid #b64b4b;
      border-right: none;
    }

    /* Variante overlay */
    .split.split--overlay {
      background: transparent;
      backdrop-filter: blur(6px);

    }

    .split.split--overlay .btn-split {
      color: #fff;
    }

    .split.split--overlay .split-right {
      background: transparent;
    }

    .controls .split {
      overflow: visible;
    }

    /* Solo per i menu in-call dentro la toolbar */
    .controls .menu.menu--overlay {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 60px;
    }

    /* =========================
   MENUS (base + overlay)
   ========================= */
    .menu {
      position: absolute;
      background: var(--surface);
      border: 1px solid var(--glass);
      border-radius: 12px;
      box-shadow: var(--shadow);
      z-index: 70;
      padding: 6px;
      bottom: 100%;
      margin-bottom: 8px;
    }

    .menu button {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      background: transparent;
      border: 0;
      color: var(--text);
      border-radius: 8px;
      cursor: pointer;
    }

    .menu button:hover,
    .menu button:focus {
      outline: none;
      background: var(--surface-2);
    }

    /* overlay positioning helper */
    .menu--overlay {
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      min-width: 260px;
    }

    /* =========================
   SNACKBAR
   ========================= */
    .snackbar {
      position: fixed;
      left: 50%;
      bottom: calc(16px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      background: var(--surface-3);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      border: 1px solid var(--glass);
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease, transform .2s ease;
      z-index: 60;
    }

    .snackbar.show {
      opacity: 1;
    }

    /* =========================
   ICON TOGGLES
   ========================= */
    #btnCamMenu {
      position: relative;
    }

    #btnCamMenu .material-symbols-rounded {
      transition: transform .2s ease;
    }

    #btnCamMenu[aria-expanded="true"] .material-symbols-rounded {
      transform: rotate(180deg);
    }

    /* =========================
   RESPONSIVE
   ========================= */
    @media (max-width: 640px) {
      .main {
        grid-template-columns: 1fr;
      }

      .side {
        display: none;
      }

      .stage {
        grid-template-columns: 1fr;
      }

      .ctrl-btn {
        --size: 48px;
      }

      .prejoin {
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
      }

      .prejoin-mobile-header {
        display: block;
      }

      .prejoin .preview {
        order: 2;
        padding: 12px 12px 8px;
      }

      .prejoin .form {
        order: 3;
        border-left: 0;
      }

      .prejoin .form .form-title {
        display: none;
      }

      /* video verticale su mobile */
      .prejoin .preview .tile {
        width: 90%;
        aspect-ratio: 9 / 16;
        height: auto;
        max-height: 50vh;
        margin: 0 auto;
      }

    }

    @media (max-width: 640px) {
      .preview {
        display: grid;
        place-items: center;
        padding: 0 12px;
        contain: layout;
      }

      .preview .tile {
        width: 80%;
        aspect-ratio: 9 / 16;
        border-radius: 14px;
        margin: 0 auto;
        overflow: hidden;
        box-shadow: var(--shadow);
      }

    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <!-- Top bar -->
    <header class="topbar" role="banner">
      <div class="brand" aria-label="App status">
        <span class="dot" id="statusDot" title="Stato connessione"></span>
        <span class="name">Videocall</span>
      </div>
      <div class="spacer"></div>
    </header>

    <!-- Main area -->
    <main class="main" role="main">
      <section class="panel stage" aria-label="Griglia video">
        <div class="tile" id="localTile" tabindex="0">
          <video id="localVideo" autoplay muted playsinline></video>

          <div class="badge">Tu</div>
        </div>
        <div class="tile" id="remoteTile" tabindex="0">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="badge" id="remoteLabel">Ospite</div>
        </div>
      </section>
    </main>

    <!-- Bottom Controls -->
    <div class="controls" role="toolbar" aria-label="Controlli chiamata">
      <div class="pill">
        <!-- CAM -->
        <div class="split" id="incallSplitCam" aria-label="Controlli fotocamera (in-call)">
          <button type="button" id="incallBtnCamMenu" class="btn-split split-left" aria-haspopup="menu"
            aria-expanded="false" title="Seleziona fotocamera">
            <span class="material-symbols-rounded" aria-hidden="true">expand_less</span>
          </button>
          <button type="button" id="incallBtnCamToggle" class="btn-split split-right" aria-pressed="true"
            title="Attiva/Disattiva fotocamera">
            <span class="material-symbols-rounded" id="incallIcCam">videocam</span>
          </button>
          <!-- Menu fotocamere -->
          <div id="incallCamMenu" class="menu menu--overlay" role="menu" hidden>
          </div>
        </div>

        <!-- MIC -->
        <div class="split" id="incallSplitMic" aria-label="Controlli microfono (in-call)">
          <button type="button" id="incallBtnMicMenu" class="btn-split split-left" aria-haspopup="menu"
            aria-expanded="false" title="Seleziona microfono">
            <span class="material-symbols-rounded" aria-hidden="true">expand_less</span>
          </button>
          <button type="button" id="incallBtnMicToggle" class="btn-split split-right" aria-pressed="true"
            title="Attiva/Disattiva microfono">
            <span class="material-symbols-rounded" id="incallIcMic">mic</span>
          </button>
          <!-- Menu microfoni -->
          <div id="incallMicMenu" class="menu menu--overlay" role="menu" hidden>
          </div>
        </div>

        <!-- HANGUP -->
        <button class="ctrl-btn danger" id="btnHangup" aria-label="Termina chiamata" title="Termina">
          <span class="material-symbols-rounded">call_end</span>
        </button>
      </div>

    </div>
  </div>

  <!-- Prejoin Modal -->
  <div class="prejoin-backdrop" id="prejoinBackdrop" role="dialog" aria-modal="true">
    <div class="prejoin" id="prejoin">
      <div class="prejoin-mobile-header">Verifica Documentazione Check-in</div>
      <div class="preview">
        <div class="tile">
          <video id="prejoinPreview" autoplay muted playsinline></video>

          <!-- Overlay controls -->
          <div class="overlay">
            <!-- Split Fotocamera (trasparente, bordo/icone bianchi) -->
            <div class="split split--overlay" id="splitCamOverlay" aria-label="Controlli fotocamera">
              <button type="button" id="btnCamMenu" class="btn-split split-left" aria-haspopup="menu"
                aria-expanded="false" title="Seleziona fotocamera">
                <span class="material-symbols-rounded" aria-hidden="true">expand_less</span>
              </button>
              <button type="button" id="btnPreviewCam" class="btn-split split-right" aria-pressed="true"
                title="Attiva/Disattiva fotocamera">
                <span class="material-symbols-rounded" id="icPreviewCam">videocam</span>
              </button>
            </div>

            <!-- Split Microfono (trasparente, bordo/icone bianchi) -->
            <div class="split split--overlay" id="splitMicOverlay" aria-label="Controlli microfono">
              <button type="button" id="btnMicMenu" class="btn-split split-left" aria-haspopup="menu"
                aria-expanded="false" title="Seleziona microfono">
                <span class="material-symbols-rounded" aria-hidden="true">expand_less</span>
              </button>
              <button type="button" id="btnPreviewMic" class="btn-split split-right" aria-pressed="true"
                title="Attiva/Disattiva microfono">
                <span class="material-symbols-rounded" id="icPreviewMic">mic</span>
              </button>
            </div>

            <!-- Menù dispositivi (aprono sopra agli split) -->
            <div id="camMenu" class="menu menu--overlay" role="menu" hidden>
            </div>
            <div id="micMenu" class="menu menu--overlay" role="menu" hidden>
            </div>
          </div>
        </div>
      </div>

      <form class="form" id="joinForm">
        <h3 class="form-title">Verifica Documentazione Check-in</h3>
        <div class="hstack">
          <button type="submit" class="btn-primary" id="startCallBtn">
            <span class="material-symbols-rounded" style="vertical-align: middle;">call</span> Entra nella
            videochiamata
          </button>
        </div>
      </form>
    </div>
  </div>



  <div class="snackbar" id="snackbar" role="status" aria-live="polite"></div>

  <!-- Logic (unchanged API, small additions at the bottom for theme & room chip) -->
  <script type="module">
    import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
    import { Device } from "https://esm.sh/mediasoup-client@3";

    // --- UI refs
    const prejoinBackdrop = document.getElementById('prejoinBackdrop');
    const prejoinPreview = document.getElementById('prejoinPreview');
    const startCallBtn = document.getElementById('startCallBtn');
    const btnCamMenu = document.getElementById('btnCamMenu');
    const btnPreviewCam = document.getElementById('btnPreviewCam');
    const icPreviewCam = document.getElementById('icPreviewCam');
    const camMenu = document.getElementById('camMenu');

    const btnMicMenu = document.getElementById('btnMicMenu');
    const btnPreviewMic = document.getElementById('btnPreviewMic');
    const icPreviewMic = document.getElementById('icPreviewMic');
    const micMenu = document.getElementById('micMenu');

    const splitCamOverlay = document.getElementById('splitCamOverlay');
    const splitMicOverlay = document.getElementById('splitMicOverlay');

    const joinForm = document.getElementById('joinForm');

    const localVideoElem = document.getElementById('localVideo');
    const remoteVideoElem = document.getElementById('remoteVideo');
    const uiStatus = document.getElementById('uiStatus');
    const statusDot = document.getElementById('statusDot');

    const btnHangup = document.getElementById('btnHangup');

    // In-call overlay controls
    const incallSplitCam = document.getElementById('incallSplitCam');
    const incallSplitMic = document.getElementById('incallSplitMic');

    const incallBtnCamMenu = document.getElementById('incallBtnCamMenu');
    const incallBtnCamToggle = document.getElementById('incallBtnCamToggle');
    const incallIcCam = document.getElementById('incallIcCam');
    const incallCamMenu = document.getElementById('incallCamMenu');

    const incallBtnMicMenu = document.getElementById('incallBtnMicMenu');
    const incallBtnMicToggle = document.getElementById('incallBtnMicToggle');
    const incallIcMic = document.getElementById('incallIcMic');
    const incallMicMenu = document.getElementById('incallMicMenu');

    const getUrlParams = () => {
      const q = new URLSearchParams(location.search);
      return {
        roomId: q.get('roomId')?.trim(),
        clientType: q.get('clientType')?.trim(), // 'guest' | 'host'
        token: q.get('token')?.trim(),
      };
    };

    // Codec preference (can be overridden in Settings in future)
    let forceCodec = null; // 'h264' | 'vp8' | null

    const snackbar = document.getElementById('snackbar');

    // --- Stato
    let socket, device, sendTransport, recvTransport, localStream, previewStream;
    let previewAudioStream = null;
    let previewCamOn = btnPreviewCam.getAttribute('aria-pressed') === 'true';
    let previewMicOn = btnPreviewMic.getAttribute('aria-pressed') === 'true';
    let currentAudioDeviceId = '';
    let audioProducer, videoProducer;
    const ownProducerIds = new Set();
    const consumedProducerIds = new Set();
    let currentVideoDeviceId = '';
    let desiredWidth = 1280, desiredHeight = 720;
    const deviceLabelMap = new Map();

    // --- Orientazione device (per mobile)
    function getDeviceOrientationAngle() {
      // API moderne (Chrome, Android, alcuni Safari recenti)
      const so = screen.orientation || screen.mozOrientation || screen.msOrientation;
      if (so && typeof so.angle === 'number') {
        console.log("angle", so.angle);
        return so.angle;
      }

      // Fallback per iOS Safari (window.orientation è deprecato ma ancora usato)
      if (typeof window.orientation === 'number') {
        // window.orientation: 0, 90, -90, 180
        let a = window.orientation;
        // Normalizziamo in [0, 360)
        if (a < 0) a += 360;
        console.log("angle", a);
        return a;
      }

      // Desktop o browser che non espongono niente: assumiamo 0
      return 0;
    }

    function isRearFromTrackOrLabel(track, deviceId) {
      try { const fm = track?.getSettings?.().facingMode; if (fm) return fm === 'environment'; } catch { }
      const label = (deviceLabelMap.get(deviceId) || '').toLowerCase();
      return /(back|rear|environment|tele|wide|ultra)/.test(label);
    }
    function setMirror(elem, isRear) { elem.classList.toggle('mirror', !isRear); }

    const remoteStream = new MediaStream();

    // --- Helpers server RPC (socket.io a server remoto)
    const serverURL = "https://videocall.webcheckin.cloud:4000";

    const joinRoom = (roomId, clientType, token) => new Promise((resolve, reject) => {
      socket.emit('joinRoom', { roomId, clientType, token }, (params) => { if (params?.error) return reject(new Error(params.error)); resolve(params); });
    });
    const getRouterCapabilities = () => new Promise((resolve, reject) => {
      socket.emit('getRouterCapabilities', null, (params) => { if (params?.error) return reject(new Error(params.error)); resolve(params.rtpCapabilities); });
    });
    const createTransport = (direction) => new Promise((resolve, reject) => {
      socket.emit('transportCreate', { direction }, (params) => {
        if (params?.error) return reject(new Error(params.error));
        const transport = direction === 'send' ? device.createSendTransport(params) : device.createRecvTransport(params);
        resolve(transport);
      });
    });
    const consume = (producerId) => new Promise((resolve, reject) => {
      socket.emit('transportConsume', { transportId: recvTransport.id, producerId, rtpCapabilities: device.rtpCapabilities }, (params) => {
        if (params?.error) return reject(new Error(params.error)); resolve(params);
      });
    });

    function setupTransportListeners(transport, direction) {
      if (transport._listenersRegistered) return;
      transport.on('connect', ({ dtlsParameters }, callback, errback) => {
        socket.emit('transportConnect', { transportId: transport.id, dtlsParameters }, (res) => { if (res?.error) errback(res.error); else callback(); });
      });
      if (direction === 'send') {
        transport.on('produce', ({ kind, rtpParameters }, callback, errback) => {
          const angle = getDeviceOrientationAngle();
          socket.emit('transportProduce', { transportId: transport.id, kind, rtpParameters, angle }, (res) => { if (res?.error) errback(res.error); else callback({ id: res.producerId }); });
        });
      }
      transport._listenersRegistered = true;
    }

    async function enumerateCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      videoDevices.forEach(d => deviceLabelMap.set(d.deviceId, d.label || ''));
      camMenu.innerHTML = '';
      if (!videoDevices.length) {
        const empty = document.createElement('div'); empty.style.padding = '10px 12px'; empty.style.color = 'var(--text-dim)'; empty.textContent = 'Nessuna fotocamera trovata'; camMenu.appendChild(empty); return videoDevices;
      }
      videoDevices.forEach((d, i) => {
        const b = document.createElement('button'); const label = d.label || `Fotocamera ${i + 1}`; b.type = 'button'; b.role = 'menuitem'; b.textContent = label; b.dataset.deviceId = d.deviceId;
        b.addEventListener('click', async () => {
          currentVideoDeviceId = d.deviceId;
          await updatePreview(currentVideoDeviceId); closeCamMenu();
        }); camMenu.appendChild(b);
      });
      return videoDevices;
    }

    async function enumerateMicrophones() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      // Popola menu microfono
      micMenu.innerHTML = '';
      if (!audioInputs.length) {
        const empty = document.createElement('div');
        empty.style.padding = '10px 12px';
        empty.style.color = 'var(--text-dim)';
        empty.textContent = 'Nessun microfono trovato';
        micMenu.appendChild(empty);
        return audioInputs;
      }

      audioInputs.forEach((d, i) => {
        const b = document.createElement('button');
        const label = d.label || `Microfono ${i + 1}`;
        b.type = 'button';
        b.role = 'menuitem';
        b.textContent = label;
        b.dataset.deviceId = d.deviceId;
        b.addEventListener('click', async () => {
          currentAudioDeviceId = d.deviceId;
          await updatePreviewAudio(currentAudioDeviceId, true);
          closeMicMenu();
        });
        micMenu.appendChild(b);
      });

      return audioInputs;
    }


    async function getUserMediaFor(deviceId, preview = false) {
      const constraints = {
        video: deviceId ? { deviceId: { exact: deviceId }, width: { ideal: desiredWidth }, height: { ideal: desiredHeight } } : { width: { ideal: desiredWidth }, height: { ideal: desiredHeight } },
        audio: preview ? false : { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      };
      return await navigator.mediaDevices.getUserMedia(constraints);
    }

    async function getUserAudioFor(deviceId) {
      const constraints = {
        audio: deviceId
          ? { deviceId: { exact: deviceId }, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
          : { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
        video: false
      };
      return await navigator.mediaDevices.getUserMedia(constraints);
    }

    async function updatePreview(deviceId) {
      try {
        if (previewStream) previewStream.getTracks().forEach(t => t.stop());
        previewStream = await getUserMediaFor(deviceId || currentVideoDeviceId, true);
        const onlyVideo = new MediaStream(previewStream.getVideoTracks());
        prejoinPreview.srcObject = onlyVideo;
        const vtrackPrev = previewStream.getVideoTracks()[0];
        if (vtrackPrev) vtrackPrev.enabled = previewCamOn;
        setMirror(prejoinPreview, isRearFromTrackOrLabel(vtrackPrev, deviceId || currentVideoDeviceId));
      } catch (e) { console.warn('Anteprima non disponibile:', e); }
    }

    async function updatePreviewAudio(deviceId, ensureOn = false) {
      try {
        if (ensureOn) {
          previewMicOn = true;
          btnPreviewMic.setAttribute('aria-pressed', 'true');
          icPreviewMic.textContent = 'mic';
        }
        if (previewAudioStream) previewAudioStream.getTracks().forEach(t => t.stop());
        previewAudioStream = await getUserAudioFor(deviceId || currentAudioDeviceId);
        const atrack = previewAudioStream.getAudioTracks()[0];
        if (atrack) atrack.enabled = previewMicOn;
        reflectOverlayStates();
      } catch (e) {
        console.warn('Anteprima audio non disponibile:', e);
      }
    }

    async function buildLocalStream(wantCam, wantMic) {
      // Se entrambi OFF, niente getUserMedia (fallirebbe)
      if (!wantCam && !wantMic) {
        localVideoElem.srcObject = null;
        return new MediaStream(); // stream vuoto
      }

      const constraints = {
        video: wantCam
          ? (currentVideoDeviceId
            ? { deviceId: { exact: currentVideoDeviceId }, width: { ideal: desiredWidth }, height: { ideal: desiredHeight } }
            : { width: { ideal: desiredWidth }, height: { ideal: desiredHeight } })
          : false,
        audio: wantMic
          ? { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
          : false
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      // Se c’è video, mostra l’anteprima locale
      const vtrack = stream.getVideoTracks()[0];
      if (vtrack) {
        localVideoElem.srcObject = new MediaStream([vtrack]);
        setMirror(localVideoElem, isRearFromTrackOrLabel(vtrack, currentVideoDeviceId));
      } else {
        localVideoElem.srcObject = null;
      }

      // (ridondante ma innocuo)
      if (vtrack) vtrack.enabled = wantCam;
      const atrack = stream.getAudioTracks()[0];
      if (atrack) atrack.enabled = wantMic;

      return stream;
    }

    async function produceTracks() {
      if (!sendTransport || !localStream) return;

      const audioTrack = localStream.getAudioTracks()[0];
      const videoTrack = localStream.getVideoTracks()[0];

      try {
        if (audioTrack && !audioProducer) {
          audioProducer = await sendTransport.produce({ track: audioTrack, paused: audioTrack.enabled === false });
        }
      } catch (err) { console.warn('[produce] audio failed', err); }

      try {
        if (videoTrack && !videoProducer) {
          videoProducer = await sendTransport.produce({ track: videoTrack, paused: videoTrack.enabled === false });
        }
      } catch (err) { console.warn('[produce] audio default failed', err?.message || err); }
      try { if (videoTrack && !videoProducer) videoProducer = await sendTransport.produce({ track: videoTrack }); }
      catch (err) {
        console.warn('[produce] video default failed', err?.message || err);
        try {
          const caps = device?.rtpCapabilities || {};
          const vCodecs = (caps.codecs || []).filter(c => /video\//i.test(c.mimeType));
          const vp8 = vCodecs.find(c => /video\/vp8/i.test(c.mimeType));
          const h264 = vCodecs.find(c => /video\/h264/i.test(c.mimeType));
          const candidates = [vp8, h264].filter(Boolean);
          for (const codec of candidates) {
            try { videoProducer = await sendTransport.produce({ track: videoTrack, codec }); console.log('[produce] video fallback OK with', codec?.mimeType); break; }
            catch (e2) { console.warn('[produce] retry failed with', codec?.mimeType, e2?.message || e2); }
          }
        } catch { }
        if (!videoProducer) toast('Impossibile inviare il video (codec non supportato)');
      }
      if (audioProducer?.id) ownProducerIds.add(audioProducer.id);
      if (videoProducer?.id) ownProducerIds.add(videoProducer.id);
      console.log('[produce] ok', { audio: !!audioProducer, video: !!videoProducer });
      reflectIncallOverlayStates();
    }

    async function subscribeToProducer(producerId) {
      if (!producerId || ownProducerIds.has(producerId) || consumedProducerIds.has(producerId)) return;
      try {
        const { id, kind, rtpParameters } = await consume(producerId);
        const consumer = await recvTransport.consume({ id, producerId, kind, rtpParameters });
        if (kind === 'video') remoteStream.getVideoTracks().forEach(t => remoteStream.removeTrack(t));
        if (kind === 'audio') remoteStream.getAudioTracks().forEach(t => remoteStream.removeTrack(t));
        remoteStream.addTrack(consumer.track);
        consumedProducerIds.add(producerId);
        remoteVideoElem.srcObject = remoteStream;
        ensurePlayback(remoteVideoElem);
        socket.emit('consumerResume', { consumerId: consumer.id }, (res) => { if (res?.error) console.error('Errore consumerResume:', res.error); });
        console.log('[consume] ok', { kind });
      } catch (err) { console.error('Errore nella subscribeToProducer:', err); toast('Errore nella sottoscrizione media'); }
    }

    async function startCall() {
      const { roomId, clientType, token } = getUrlParams();
      if (!roomId || !clientType || !token) { toast("Compila roomId, clientType e token."); return; }
      socket = io(serverURL, { query: { roomId, authToken: token, clientType } });
      const waitForConnect = s => new Promise(res => s.connected ? res() : s.once('connect', res));
      await waitForConnect(socket);

      socket.on('connect_error', (e) => { console.error('[socket connect_error]', e?.message || e); toast('Errore di connessione'); });
      const { canJoinRoom, existingProducers } = await joinRoom(roomId, clientType, token);
      if (!canJoinRoom) { setStatus(false, 'Accesso negato'); toast('Accesso alla room negato'); socket?.disconnect(); return; }
      const routerRtpCapabilities = await getRouterCapabilities();
      device = new Device(); await device.load({ routerRtpCapabilities });
      if (!device.canProduce('audio') && !device.canProduce('video')) { toast('Questo device non può produrre audio o video.'); return; }
      const wantCam = previewCamOn;
      const wantMic = previewMicOn;
      localStream = await buildLocalStream(wantCam, wantMic);
      sendTransport = await createTransport('send'); setupTransportListeners(sendTransport, 'send'); sendTransport.on('connectionstatechange', (state) => { console.log('[sendTransport] state', state); });
      recvTransport = await createTransport('recv'); setupTransportListeners(recvTransport, 'recv'); recvTransport.on('connectionstatechange', (state) => { console.log('[recvTransport] state', state); });
      await produceTracks();
      reflectIncallOverlayStates();
      for (const p of (existingProducers || [])) { const prodId = p.producerId ?? p; await subscribeToProducer(prodId, p?.appData?.socketId); }
      socket.on('newProducer', ({ producerId }) => { const doSub = () => subscribeToProducer(producerId).catch(() => { }); setTimeout(doSub, 0); setTimeout(doSub, 300); });
      socket.on('hangup', hangupCall);
      socket.on('connect', () => setStatus(true, 'Connesso'));
      socket.io.engine.on && socket.io.engine.on('upgrade', () => console.log('[socket] upgraded to WebSocket'));
      socket.on('disconnect', () => setStatus(false, 'Disconnesso'));
      prejoinBackdrop.style.display = 'none';
      ensurePlayback(remoteVideoElem);
      toast('Videochiamata avviata');
    }

    function reflectIncallOverlayStates() {
      const v = localStream?.getVideoTracks?.()[0];
      const a = localStream?.getAudioTracks?.()[0];

      const camOn = !!v && v.enabled !== false;
      const micOn = !!a && a.enabled !== false;

      incallSplitCam.classList.toggle('is-off', !camOn);
      incallSplitMic.classList.toggle('is-off', !micOn);
      incallIcCam.textContent = camOn ? 'videocam' : 'videocam_off';
      incallIcMic.textContent = micOn ? 'mic' : 'mic_off';
      incallBtnCamToggle.setAttribute('aria-pressed', String(camOn));
      incallBtnMicToggle.setAttribute('aria-pressed', String(micOn));
    }

    async function toggleCamIncall() {
      // Stream sempre presente (anche vuoto) dopo startCall
      if (!localStream) localStream = new MediaStream();

      let track = localStream.getVideoTracks()[0];

      // Caso 1: NESSUNA traccia -> avvia la camera
      if (!track) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: currentVideoDeviceId
              ? { deviceId: { exact: currentVideoDeviceId }, width: { ideal: desiredWidth }, height: { ideal: desiredHeight } }
              : { width: { ideal: desiredWidth }, height: { ideal: desiredHeight } },
            audio: false
          });
          const newTrack = stream.getVideoTracks()[0];
          localStream.addTrack(newTrack);
          localVideoElem.srcObject = new MediaStream([newTrack]);
          setMirror(localVideoElem, isRearFromTrackOrLabel(newTrack, currentVideoDeviceId));

          if (videoProducer) {
            await videoProducer.replaceTrack({ track: newTrack });
            await videoProducer.resume(); // assicurati che trasmetta
          } else if (sendTransport) {
            videoProducer = await sendTransport.produce({ track: newTrack });
            ownProducerIds.add(videoProducer.id);
          }
          reflectIncallOverlayStates();
          toast('Fotocamera attivata');
        } catch (e) {
          console.error('toggleCamIncall start error', e);
          toast('Impossibile avviare la fotocamera');
        }
        return;
      }

      // Caso 2: c’è traccia -> toggle ON/OFF
      track.enabled = !track.enabled;
      try {
        if (videoProducer) {
          track.enabled ? await videoProducer.resume() : await videoProducer.pause();
        }
      } catch { /* ignora */ }
      reflectIncallOverlayStates();
      toast(track.enabled ? 'Fotocamera attivata' : 'Fotocamera disattivata');
    }

    async function toggleMicIncall() {
      if (!localStream) localStream = new MediaStream();

      let track = localStream.getAudioTracks()[0];

      if (!track) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
            video: false
          });
          const newTrack = stream.getAudioTracks()[0];
          localStream.addTrack(newTrack);

          if (audioProducer) {
            await audioProducer.replaceTrack({ track: newTrack });
            await audioProducer.resume();
          } else if (sendTransport) {
            audioProducer = await sendTransport.produce({ track: newTrack });
            ownProducerIds.add(audioProducer.id);
          }
          reflectIncallOverlayStates();
          toast('Microfono attivato');
        } catch (e) {
          console.error('toggleMicIncall start error', e);
          toast('Impossibile avviare il microfono');
        }
        return;
      }

      track.enabled = !track.enabled;
      try {
        if (audioProducer) {
          track.enabled ? await audioProducer.resume() : await audioProducer.pause();
        }
      } catch { }
      reflectIncallOverlayStates();
      toast(track.enabled ? 'Microfono attivato' : 'Microfono disattivato');
    }

    function openIncallCamMenu() { incallCamMenu.hidden = false; incallBtnCamMenu.setAttribute('aria-expanded', 'true'); }
    function closeIncallCamMenu() { incallCamMenu.hidden = true; incallBtnCamMenu.setAttribute('aria-expanded', 'false'); }
    function toggleIncallCamMenu() {
      if (incallCamMenu.hidden) {
        closeIncallMicMenu();
        openIncallCamMenu();
      } else {
        closeIncallCamMenu();
      }
    }

    function openIncallMicMenu() { incallMicMenu.hidden = false; incallBtnMicMenu.setAttribute('aria-expanded', 'true'); }
    function closeIncallMicMenu() { incallMicMenu.hidden = true; incallBtnMicMenu.setAttribute('aria-expanded', 'false'); }
    function toggleIncallMicMenu() {
      if (incallMicMenu.hidden) {
        closeIncallCamMenu();
        openIncallMicMenu();
      }
      else
        closeIncallMicMenu();
    }

    /* Popola i menu dispositivi IN-CALL */
    async function populateIncallCamMenu() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      incallCamMenu.innerHTML = '';
      if (!cams.length) {
        const empty = document.createElement('div');
        empty.style.padding = '10px 12px'; empty.style.color = 'var(--text-dim)';
        empty.textContent = 'Nessuna fotocamera trovata'; incallCamMenu.appendChild(empty); return;
      }
      cams.forEach((d, i) => {
        const b = document.createElement('button');
        b.type = 'button'; b.role = 'menuitem'; b.textContent = d.label || `Fotocamera ${i + 1}`;
        b.addEventListener('click', () => switchIncallCamera(d.deviceId));
        incallCamMenu.appendChild(b);
      });
    }

    async function populateIncallMicMenu() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const mics = devices.filter(d => d.kind === 'audioinput');
      incallMicMenu.innerHTML = '';
      if (!mics.length) {
        const empty = document.createElement('div');
        empty.style.padding = '10px 12px'; empty.style.color = 'var(--text-dim)';
        empty.textContent = 'Nessun microfono trovato'; incallMicMenu.appendChild(empty); return;
      }
      mics.forEach((d, i) => {
        const b = document.createElement('button');
        b.type = 'button'; b.role = 'menuitem'; b.textContent = d.label || `Microfono ${i + 1}`;
        b.addEventListener('click', () => switchIncallMic(d.deviceId));
        incallMicMenu.appendChild(b);
      });
    }

    /* Sostituisce la fotocamera DURANTE la chiamata */
    async function switchIncallCamera(deviceId) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: deviceId }, width: { ideal: desiredWidth }, height: { ideal: desiredHeight } },
          audio: false
        });
        const newTrack = stream.getVideoTracks()[0];
        const oldTrack = localStream.getVideoTracks()[0];
        if (videoProducer) await videoProducer.replaceTrack({ track: newTrack });
        localStream.removeTrack(oldTrack); oldTrack.stop();
        localStream.addTrack(newTrack);
        localVideoElem.srcObject = new MediaStream([newTrack]);
        currentVideoDeviceId = deviceId;
        reflectIncallOverlayStates();
        toast('Fotocamera cambiata');
        closeIncallCamMenu();
      } catch (e) {
        console.error('switchIncallCamera error', e);
        toast('Impossibile cambiare fotocamera');
      }
    }

    /* Sostituisce il microfono DURANTE la chiamata */
    async function switchIncallMic(deviceId) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: { exact: deviceId }, echoCancellation: true, noiseSuppression: true, autoGainControl: true },
          video: false
        });
        const newTrack = stream.getAudioTracks()[0];
        const oldTrack = localStream.getAudioTracks()[0];
        if (audioProducer) await audioProducer.replaceTrack({ track: newTrack });
        if (oldTrack) { localStream.removeTrack(oldTrack); oldTrack.stop(); }
        localStream.addTrack(newTrack);
        reflectIncallOverlayStates();
        toast('Microfono cambiato');
        closeIncallMicMenu();
      } catch (e) {
        console.error('switchIncallMic error', e);
        toast('Impossibile cambiare microfono');
      }
    }

    incallBtnCamToggle.addEventListener('click', toggleCamIncall);
    incallBtnMicToggle.addEventListener('click', toggleMicIncall);

    incallBtnCamMenu.addEventListener('click', (e) => { e.stopPropagation(); populateIncallCamMenu().then(() => toggleIncallCamMenu()); });
    incallBtnMicMenu.addEventListener('click', (e) => { e.stopPropagation(); populateIncallMicMenu().then(() => toggleIncallMicMenu()); });

    document.addEventListener('click', (e) => {
      if (!incallCamMenu.hidden && !incallCamMenu.contains(e.target) && e.target !== incallBtnCamMenu) closeIncallCamMenu();
      if (!incallMicMenu.hidden && !incallMicMenu.contains(e.target) && e.target !== incallBtnMicMenu) closeIncallMicMenu();
    });

    function setStatus(connected, label) { statusDot.style.background = connected ? 'var(--ok)' : 'var(--danger)'; }
    function toast(msg, ms = 1800) { snackbar.textContent = msg; snackbar.classList.add('show'); setTimeout(() => snackbar.classList.remove('show'), ms); }

    function openCamMenu() { camMenu.hidden = false; btnCamMenu.setAttribute('aria-expanded', 'true'); }
    function closeCamMenu() { camMenu.hidden = true; btnCamMenu.setAttribute('aria-expanded', 'false'); }
    function toggleCamMenu() {
      if (camMenu.hidden) {
        closeMicMenu();
        openCamMenu()
      }
      else
        closeCamMenu();
    }

    function openMicMenu() { micMenu.hidden = false; btnMicMenu.setAttribute('aria-expanded', 'true'); }
    function closeMicMenu() { micMenu.hidden = true; btnMicMenu.setAttribute('aria-expanded', 'false'); }
    function toggleMicMenu() {
      if (micMenu.hidden) {
        closeCamMenu();
        openMicMenu()
      } else
        closeMicMenu();
    }

    function togglePreviewCameraTrack() {
      previewCamOn = !previewCamOn;

      const t = prejoinPreview.srcObject?.getVideoTracks?.()[0];
      if (t) t.enabled = previewCamOn;

      btnPreviewCam.setAttribute('aria-pressed', String(previewCamOn));
      icPreviewCam.textContent = previewCamOn ? 'videocam' : 'videocam_off';
      reflectOverlayStates();
    }

    async function switchCamera(nextId) {
      const videos = await enumerateCameras(); if (!videos.length) return;
      let idx = videos.findIndex(v => v.deviceId === (nextId || currentVideoDeviceId)); idx = (idx + 1) % videos.length; const newId = videos[idx].deviceId;
      await updatePreview(newId);
      if (sendTransport) {
        const newStream = await getUserMediaFor(newId, false); const newTrack = newStream.getVideoTracks()[0];
        if (videoProducer) await videoProducer.replaceTrack({ track: newTrack });
        localStream.getVideoTracks().forEach(t => t.stop());
        localStream.removeTrack(localStream.getVideoTracks()[0]);
        localStream.addTrack(newTrack);
        localVideoElem.srcObject = new MediaStream([newTrack]);
        setMirror(localVideoElem, isRearFromTrackOrLabel(newTrack, newId));
      }
      currentVideoDeviceId = newId;
      toast('Fotocamera cambiata');
    }
    
    function togglePreviewMicTrack() {
      previewMicOn = !previewMicOn;

      const t = previewAudioStream?.getAudioTracks?.()[0];
      if (t) t.enabled = previewMicOn;

      btnPreviewMic.setAttribute('aria-pressed', String(previewMicOn));
      icPreviewMic.textContent = previewMicOn ? 'mic' : 'mic_off';
      reflectOverlayStates();
    }

    function reflectOverlayStates() {
      splitCamOverlay.classList.toggle('is-off', !previewCamOn);
      splitMicOverlay.classList.toggle('is-off', !previewMicOn);
    }

    function hangupCall() {
      try {
        if (audioProducer) { audioProducer.close(); audioProducer = null; }
        if (videoProducer) { videoProducer.close(); videoProducer = null; }
        if (sendTransport) { sendTransport.close(); sendTransport = null; }
        if (recvTransport) { recvTransport.close(); recvTransport = null; }
        if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
        if (socket) { socket.disconnect(); socket = null; }
        ownProducerIds.clear(); consumedProducerIds.clear();
        localVideoElem.srcObject = null; remoteVideoElem.srcObject = null;
        setStatus(false, 'Terminata'); prejoinBackdrop.style.display = 'grid'; updatePreview(currentVideoDeviceId); toast('Chiamata terminata');
        reflectIncallOverlayStates();
      } catch (e) { console.error('Errore in hangup:', e); }
    }

    // --- Event wiring
    joinForm.addEventListener('submit', (e) => { e.preventDefault(); startCall().catch(err => { console.error(err); toast(err.message || 'Errore avvio'); }); });

    btnHangup.addEventListener('click', () => { socket?.emit?.('hangup'); hangupCall(); });
    btnCamMenu.addEventListener('click', (e) => { e.stopPropagation(); toggleCamMenu(); });
    btnPreviewCam.addEventListener('click', () => { togglePreviewCameraTrack(); });
    document.addEventListener('click', (e) => { if (!camMenu.hidden && !camMenu.contains(e.target) && e.target !== btnCamMenu) { closeCamMenu(); } });

    btnMicMenu.addEventListener('click', (e) => { e.stopPropagation(); toggleMicMenu(); });
    btnPreviewMic.addEventListener('click', () => { togglePreviewMicTrack(); });

    document.addEventListener('click', (e) => {
      if (!camMenu.hidden && !camMenu.contains(e.target) && e.target !== btnCamMenu) { closeCamMenu(); }
      if (!micMenu.hidden && !micMenu.contains(e.target) && e.target !== btnMicMenu) { closeMicMenu(); }
    });

    // --- UX boot
    window.addEventListener('load', async () => {
      try { const saved = localStorage.getItem('vc-theme'); if (saved) document.documentElement.setAttribute('data-theme', saved); } catch { }

      const { roomId, clientType, token } = getUrlParams();
      const hasParams = !!(roomId && clientType && token);
      startCallBtn.disabled = !hasParams;
      startCallBtn.title = hasParams ? 'Avvia' : 'Aggiungi roomId, clientType e token alla URL';

      try { const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: true }); tmp.getTracks().forEach(t => t.stop()); } catch (err) { console.warn('Permessi media non concessi in anticipo (verranno richiesti al click).', err); }
      await enumerateCameras();
      await enumerateMicrophones();

      // Imposta default mic se non presente
      const mics = await enumerateMicrophones();
      if (!currentAudioDeviceId && mics.length) {
        currentAudioDeviceId = mics[0].deviceId;
      }

      const vids = await enumerateCameras();
      if (!currentVideoDeviceId && vids.length) { currentVideoDeviceId = vids[0].deviceId; }
      await updatePreview(currentVideoDeviceId);
      btnPreviewCam.setAttribute('aria-pressed', 'true');
      icPreviewCam.textContent = 'videocam';

      await updatePreviewAudio(currentAudioDeviceId, true);
      btnPreviewMic.setAttribute('aria-pressed', 'true');
      icPreviewMic.textContent = 'mic';

      reflectOverlayStates();
    });

    function ensurePlayback(videoEl) {
      if (!videoEl) return;
      const tryPlay = () => {
        const p = videoEl.play?.();
        if (p && typeof p.then === 'function') {
          p.catch(() => { });
        }
      };
      tryPlay();
      videoEl.addEventListener('loadedmetadata', tryPlay, { once: true });
    }

  </script>
</body>

</html>
