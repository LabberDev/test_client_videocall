<!DOCTYPE html>
<html lang="it">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Videocall • Meet‑style UI</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
  <style>
    :root {
      --bg: #0b0f14;
      --surface: #151b22;
      --surface-2: #1b232d;
      --text: #e7eef7;
      --text-dim: #b7c2cf;
      --primary: #5c9dff;
      --danger: #ff5c7a;
      --ok: #3ddc97;
      --warn: #ffce5c;
      --shadow: 0 6px 24px rgba(0, 0, 0, .35);
      --radius: 16px;
      --ring: 0 0 0 2px rgba(92, 157, 255, .45);
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      line-height: 1.5;
    }

    body { margin: 0; }

    button, input, select { font: inherit; color: inherit; }

    .app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100svh;
    }

    /* Top App Bar */
    .topbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px clamp(12px, 3vw, 24px);
      background: linear-gradient(180deg, rgba(21,27,34,.9), rgba(21,27,34,.7));
      border-bottom: 1px solid rgba(255,255,255,.06);
      position: sticky;
      top: 0; z-index: 30;
      backdrop-filter: blur(10px);
    }
    .brand {
      display: flex; align-items: center; gap: 10px;
      font-weight: 700; letter-spacing: .2px;
    }
    .brand .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--ok); box-shadow: 0 0 0 4px rgba(61,220,151,.15); }
    .spacer { flex: 1; }
    .top-actions { display:flex; gap:8px; align-items:center; }

    /* Main */
    .main {
      display: grid;
      grid-template-columns: 1fr minmax(0, 320px);
      gap: 12px;
      padding: 12px;
    }
    .panel {
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      min-height: 0;
    }

    /* Stage: video grid */
    .stage {
      position: relative;
      padding: 12px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .tile {
      position: relative;
      border-radius: calc(var(--radius) - 6px);
      overflow: hidden;
      background: #000;
      isolation: isolate;
      min-height: 220px;
    }
    video { width: 100%; height: 100%; display: block; object-fit: cover; background: #000; }
    .mirror { transform: scaleX(-1); }
    .badge {
      position: absolute; left: 12px; bottom: 12px;
      padding: 6px 10px; border-radius: 999px;
      background: rgba(0,0,0,.45); color: #fff; font-size: .9rem; backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,.1);
    }
    .muted-indicator { position:absolute; right: 12px; bottom: 12px; background: rgba(0,0,0,.45); border-radius: 50%; width: 36px; height: 36px; display:grid; place-items:center; }

    /* Right side panel (collapsible) */
    .side {
      display: grid; grid-template-rows: auto 1fr;
    }
    .side header { padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,.06); font-weight: 600; }
    .side .content { padding: 12px; overflow: auto; color: var(--text-dim); }

    /* Bottom Controls */
    .controls {
      position: sticky; bottom: 0;
      padding: max(8px, env(safe-area-inset-bottom));
      display: flex; justify-content: center; gap: 10px;
      background: linear-gradient(0deg, rgba(21,27,34,.9), rgba(21,27,34,0));
      z-index: 20;
    }
    .pill {
      display:flex; gap:8px; padding: 10px; background: var(--surface); border-radius: 999px; box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.06);
    }
    .ctrl-btn {
      --size: 48px;
      width: var(--size); height: var(--size); border-radius: 999px; border: 1px solid rgba(255,255,255,.08);
      background: var(--surface-2); display:grid; place-items:center; cursor:pointer;
      transition: transform .06s ease;
    }
    .ctrl-btn:active { transform: scale(.97); }
    .ctrl-btn[aria-pressed="true"] { outline: none; box-shadow: var(--ring); }
    .ctrl-btn.danger { background: var(--danger); border-color: rgba(0,0,0,.2); }
    .ctrl-btn .material-symbols-rounded { font-variation-settings: 'FILL' 1; }

    /* Prejoin Sheet */
    .prejoin-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.6); backdrop-filter: blur(6px); display: grid; place-items: center; z-index: 50; }
    .prejoin {
      width: min(920px, 92vw);
      background: var(--surface);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      display: grid; grid-template-columns: 1fr 360px;
    }
    .prejoin .preview { background: #000; min-height: 260px; }
    .prejoin .form { padding: 16px; border-left: 1px solid rgba(255,255,255,.06); display: grid; gap: 10px; }
    .field { display: grid; gap: 6px; }
    .field label { color: var(--text-dim); font-size: .9rem; }
    .input, .select { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.12); background: var(--surface-2); color: var(--text); }
    .btn-primary { padding: 12px 14px; background: var(--primary); border: none; color: #00122b; border-radius: 12px; cursor: pointer; font-weight: 700; }
    .btn-secondary { padding: 10px 12px; background: var(--surface-2); border: 1px solid rgba(255,255,255,.12); color: var(--text); border-radius: 10px; cursor: pointer; }
    .hstack { display:flex; gap: 8px; align-items:center; }
    .preview .tile { height: 100%; border-radius: 0; }

    /* Snackbar */
    .snackbar { position: fixed; left: 50%; bottom: calc(16px + env(safe-area-inset-bottom)); transform: translateX(-50%); background: #1f2937; color: #fff; padding: 10px 14px; border-radius: 12px; box-shadow: var(--shadow); opacity: 0; pointer-events:none; transition: opacity .2s ease, transform .2s ease; z-index: 60; }
    .snackbar.show { opacity: 1; }

    /* Responsive */
    @media (max-width: 1024px) {
      .main { grid-template-columns: 1fr; }
      .side { display: none; }
      .stage { grid-template-columns: 1fr; }
      .prejoin { grid-template-columns: 1fr; }
      .prejoin .form { border-left: 0; border-top: 1px solid rgba(255,255,255,.06); }
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <!-- Top bar -->
    <header class="topbar" role="banner">
      <div class="brand" aria-label="App status">
        <span class="dot" id="statusDot" title="Stato connessione"></span>
        <span>Videocall</span>
      </div>
      <div class="spacer"></div>
      <div class="top-actions">
        <button class="btn-secondary" id="openSettings"><span class="material-symbols-rounded" aria-hidden="true">tune</span> Impostazioni</button>
      </div>
    </header>

    <!-- Main area -->
    <main class="main" role="main">
      <section class="panel stage" aria-label="Griglia video">
        <div class="tile" id="localTile">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="badge">Tu</div>
          <div class="muted-indicator" id="micBadgeLocal" title="Microfono disattivato" hidden>
            <span class="material-symbols-rounded">mic_off</span>
          </div>
        </div>
        <div class="tile" id="remoteTile">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="badge" id="remoteLabel">Ospite</div>
          <div class="muted-indicator" id="micBadgeRemote" hidden>
            <span class="material-symbols-rounded">mic_off</span>
          </div>
        </div>
      </section>

      <aside class="panel side" aria-label="Pannello laterale" id="sidePanel">
        <header>Dettagli riunione</header>
        <div class="content">
          <div class="field"><label>Room ID</label><div id="uiRoomId" style="font-weight:600;"></div></div>
          <div class="field"><label>Client</label><div id="uiClientType"></div></div>
          <div class="field"><label>Stato</label><div id="uiStatus">Non connesso</div></div>
          <hr style="border-color: rgba(255,255,255,.06); margin: 12px 0;">
          <div style="font-size:.9rem; color: var(--text-dim)">Suggerimento: puoi passare i parametri via URL, es.
            <code>?roomId=room789_1&amp;clientType=guest&amp;token=guest_1</code>
          </div>
        </div>
      </aside>
    </main>

    <!-- Bottom Controls -->
    <div class="controls" role="toolbar" aria-label="Controlli chiamata">
      <div class="pill" id="controlsPill">
        <button class="ctrl-btn" id="btnMic" aria-label="Attiva/Disattiva microfono" aria-pressed="true" title="Microfono">
          <span class="material-symbols-rounded" id="icMic">mic</span>
        </button>
        <button class="ctrl-btn" id="btnCam" aria-label="Attiva/Disattiva fotocamera" aria-pressed="true" title="Fotocamera">
          <span class="material-symbols-rounded" id="icCam">videocam</span>
        </button>
        <button class="ctrl-btn" id="btnSwitchCam" aria-label="Cambia fotocamera" title="Cambia fotocamera">
          <span class="material-symbols-rounded">cameraswitch</span>
        </button>
        <button class="ctrl-btn danger" id="btnHangup" aria-label="Termina chiamata" title="Termina">
          <span class="material-symbols-rounded">call_end</span>
        </button>
        <button class="ctrl-btn" id="btnUnmute" aria-label="Attiva audio remoto" title="Attiva audio" style="display:none;">
          <span class="material-symbols-rounded">volume_up</span>
        </button>
        <button class="ctrl-btn" id="btnSettings" aria-label="Impostazioni" title="Impostazioni">
          <span class="material-symbols-rounded">tune</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Prejoin Modal -->
  <div class="prejoin-backdrop" id="prejoinBackdrop" role="dialog" aria-modal="true">
    <div class="prejoin" id="prejoin">
      <div class="preview">
        <div class="tile">
          <video id="prejoinPreview" autoplay muted playsinline></video>
          <div class="badge">Anteprima</div>
        </div>
      </div>
      <form class="form" id="joinForm">
        <div class="field">
          <label for="roomId">Room ID</label>
          <input id="roomId" class="input" type="text" placeholder="es. room789_1" required />
        </div>
        <div class="field">
          <label for="clientType">Client Type</label>
          <select id="clientType" class="select">
            <option value="guest">guest</option>
            <option value="host">host</option>
          </select>
        </div>
        <div class="field">
          <label for="token">Token</label>
          <input id="token" class="input" type="text" placeholder="es. guest_1" required />
        </div>
        <div class="field">
          <label for="videoSource">Seleziona fotocamera</label>
          <select id="videoSource" class="select"></select>
        </div>
        <div class="hstack" style="margin-top:6px;">
          <button type="submit" class="btn-primary" id="startCallBtn"><span class="material-symbols-rounded" style="vertical-align: middle;">call</span> Avvia</button>
          <button type="button" class="btn-secondary" id="togglePreviewCam"><span class="material-symbols-rounded" aria-hidden="true">videocam_off</span> Disattiva cam</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Settings Drawer (lightweight) -->
  <dialog id="settingsDlg" style="border:none; border-radius:16px; padding:0; background:var(--surface); color:var(--text); width:min(520px, 92vw);">
    <form method="dialog" style="display:grid; grid-template-rows:auto 1fr auto; max-height: 80svh;">
      <header style="padding:12px 16px; border-bottom:1px solid rgba(255,255,255,.06); font-weight:700;">Impostazioni</header>
      <div style="padding:16px; display:grid; gap:12px; overflow:auto;">
        <div class="field">
          <label for="videoSource2">Fotocamera</label>
          <select id="videoSource2" class="select"></select>
        </div>
        <div class="field">
          <label for="quality">Qualità video</label>
          <select id="quality" class="select">
            <option value="1280x720">HD 720p</option>
            <option value="640x360">SD 360p</option>
          </select>
        </div>
      </div>
      <footer style="padding:12px 16px; border-top:1px solid rgba(255,255,255,.06); display:flex; justify-content:flex-end; gap:8px;">
        <button class="btn-secondary" value="cancel">Chiudi</button>
      </footer>
    </form>
  </dialog>

  <div class="snackbar" id="snackbar" role="status" aria-live="polite"></div>

  <!-- Logic -->
  <script type="module">
    import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
    import { Device } from "https://esm.sh/mediasoup-client@3";

    // --- UI refs
    const prejoinBackdrop = document.getElementById('prejoinBackdrop');
    const prejoinPreview = document.getElementById('prejoinPreview');
    const startCallBtn = document.getElementById('startCallBtn');
    const togglePreviewCamBtn = document.getElementById('togglePreviewCam');

    const joinForm = document.getElementById('joinForm');
    const roomIdInput = document.getElementById('roomId');
    const clientTypeInput = document.getElementById('clientType');
    const tokenInput = document.getElementById('token');
    const videoSourceSelect = document.getElementById('videoSource');
    const videoSourceSelect2 = document.getElementById('videoSource2');

    const localVideoElem = document.getElementById('localVideo');
    const remoteVideoElem = document.getElementById('remoteVideo');
    const remoteLabel = document.getElementById('remoteLabel');
    const uiRoomId = document.getElementById('uiRoomId');
    const uiClientType = document.getElementById('uiClientType');
    const uiStatus = document.getElementById('uiStatus');
    const statusDot = document.getElementById('statusDot');

    const btnMic = document.getElementById('btnMic');
    const btnCam = document.getElementById('btnCam');
    const btnSwitchCam = document.getElementById('btnSwitchCam');
    const btnHangup = document.getElementById('btnHangup');
    const btnSettings = document.getElementById('btnSettings');
    const btnUnmute = document.getElementById('btnUnmute');
    const openSettings = document.getElementById('openSettings');
    const settingsDlg = document.getElementById('settingsDlg');
    const qualitySelect = document.getElementById('quality');

    const snackbar = document.getElementById('snackbar');

    // --- Stato
    let socket, device, sendTransport, recvTransport, localStream, previewStream;
    let audioProducer, videoProducer;
    let currentVideoDeviceId = '';
      let desiredWidth = 1280, desiredHeight = 720;
      const deviceLabelMap = new Map();
      function isRearFromTrackOrLabel(track, deviceId) {
        try {
          const fm = track?.getSettings?.().facingMode;
          if (fm) return fm === 'environment';
        } catch {}
        const label = (deviceLabelMap.get(deviceId) || '').toLowerCase();
        return /(back|rear|environment|tele|wide|ultra)/.test(label);
      }
      function setMirror(elem, isRear) {
        // mirror only for front camera
        elem.classList.toggle('mirror', !isRear);
      }

    const remoteStream = new MediaStream();

    async function ensurePlayback(videoEl) {
      try {
        videoEl.muted = false; // vogliamo l'audio remoto
        const playPromise = videoEl.play();
        if (playPromise) await playPromise;
        btnUnmute.style.display = 'none';
      } catch (e) {
        // Autoplay policy ha bloccato: mostra pulsante
        btnUnmute.style.display = 'grid';
      }
    }

    // --- Helpers server RPC (socket.io a server remoto)
    const serverURL = "https://videocall.webcheckin.cloud:4000";

    const joinRoom = (roomId, clientType, token) => new Promise((resolve, reject) => {
      socket.emit('joinRoom', { roomId, clientType, token }, (params) => {
        if (params?.error) return reject(new Error(params.error));
        resolve(params);
      });
    });

    const getRouterCapabilities = () => new Promise((resolve, reject) => {
      socket.emit('getRouterCapabilities', null, (params) => {
        if (params?.error) return reject(new Error(params.error));
        resolve(params.rtpCapabilities);
      });
    });

    const createTransport = (direction) => new Promise((resolve, reject) => {
      socket.emit('transportCreate', { direction }, (params) => {
        if (params?.error) return reject(new Error(params.error));
        const transport = direction === 'send'
          ? device.createSendTransport(params)
          : device.createRecvTransport(params);
        resolve(transport);
      });
    });

    const consume = (producerId) => new Promise((resolve, reject) => {
      socket.emit('transportConsume', {
        transportId: recvTransport.id,
        producerId,
        rtpCapabilities: device.rtpCapabilities
      }, (params) => {
        if (params?.error) return reject(new Error(params.error));
        resolve(params);
      });
    });

    function setupTransportListeners(transport, direction) {
      if (transport._listenersRegistered) return;
      transport.on('connect', ({ dtlsParameters }, callback, errback) => {
        socket.emit('transportConnect', { transportId: transport.id, dtlsParameters }, (res) => {
          if (res?.error) errback(res.error); else callback();
        });
      });
      if (direction === 'send') {
        transport.on('produce', ({ kind, rtpParameters }, callback, errback) => {
          socket.emit('transportProduce', { transportId: transport.id, kind, rtpParameters }, (res) => {
            if (res?.error) errback(res.error); else callback({ id: res.producerId });
          });
        });
      }
      transport._listenersRegistered = true;
    }

    async function enumerateCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      const fillSelect = (sel) => {
        sel.innerHTML = '';
        videoDevices.forEach((d, i) => {
          deviceLabelMap.set(d.deviceId, d.label || '');
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Fotocamera ${i + 1}`;
          sel.appendChild(opt);
        });
        if (currentVideoDeviceId) sel.value = currentVideoDeviceId;
      };
      fillSelect(videoSourceSelect);
      fillSelect(videoSourceSelect2);
      return videoDevices;
    }

    async function getUserMediaFor(deviceId, preview = false) {
      const constraints = {
        video: deviceId ? {
          deviceId: { exact: deviceId },
          width: { ideal: desiredWidth },
          height: { ideal: desiredHeight }
        } : {
          width: { ideal: desiredWidth },
          height: { ideal: desiredHeight }
        },
        audio: preview ? false : { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      };
      return await navigator.mediaDevices.getUserMedia(constraints);
    }

    async function updatePreview(deviceId) {
      try {
        if (previewStream) previewStream.getTracks().forEach(t => t.stop());
        previewStream = await getUserMediaFor(deviceId || currentVideoDeviceId, true);
        const onlyVideo = new MediaStream(previewStream.getVideoTracks());
        prejoinPreview.srcObject = onlyVideo;
        const vtrackPrev = previewStream.getVideoTracks()[0];
        setMirror(prejoinPreview, isRearFromTrackOrLabel(vtrackPrev, deviceId || currentVideoDeviceId));
      } catch (e) { console.warn('Anteprima non disponibile:', e); }
    }

    async function buildLocalStream() {
      const selId = videoSourceSelect.value || currentVideoDeviceId;
      const stream = await getUserMediaFor(selId, false);
      currentVideoDeviceId = selId || currentVideoDeviceId;
      const preview = new MediaStream(stream.getVideoTracks());
      localVideoElem.srcObject = preview;
      const vtrackLocal = stream.getVideoTracks()[0];
      setMirror(localVideoElem, isRearFromTrackOrLabel(vtrackLocal, currentVideoDeviceId));
      return stream;
    }

    async function produceTracks() {
      if (!sendTransport || !localStream) return;
      const audioTrack = localStream.getAudioTracks()[0];
      const videoTrack = localStream.getVideoTracks()[0];

      // Preferenze codec per massima compatibilità desktop (Safari/HW accel)
      const caps = device.rtpCapabilities;
      const preferH264 = caps?.codecs?.find(c => /video\/h264/i.test(c.mimeType));
      const preferVP8  = caps?.codecs?.find(c => /video\/vp8/i.test(c.mimeType));
      const videoCodec = preferH264 || preferVP8 || undefined;
      const opus       = caps?.codecs?.find(c => /audio\/opus/i.test(c.mimeType));

      try {
        if (audioTrack) audioProducer = await sendTransport.produce({ track: audioTrack, codec: opus });
        if (videoTrack) videoProducer = await sendTransport.produce({ track: videoTrack, codec: videoCodec });
        console.log('[produce] ok', { audio: !!audioProducer, video: !!videoProducer, videoCodec: videoCodec?.mimeType });
      } catch (err) {
        console.error('[produce] failed', err);
        toast('Errore nel publish delle tracce');
      }
    }

    async function subscribeToProducer(producerId, remoteSocketId) {
      if (!producerId) return;
      try {
        const { id, kind, rtpParameters } = await consume(producerId);
        const consumer = await recvTransport.consume({ id, producerId, kind, rtpParameters });
        remoteStream.addTrack(consumer.track);
        remoteVideoElem.srcObject = remoteStream;
        ensurePlayback(remoteVideoElem);
        socket.emit('consumerResume', { consumerId: consumer.id }, (res) => {
          if (res?.error) console.error("Errore consumerResume:", res.error);
        });
      } catch (err) {
        console.error("Errore nella subscribeToProducer:", err);
      }
    }

    async function startCall() {
      const roomId = roomIdInput.value.trim();
      const clientType = clientTypeInput.value.trim();
      const token = tokenInput.value.trim();
      if (!roomId || !clientType || !token) {
        toast("Compila roomId, clientType e token.");
        return;
      }

      socket = io(serverURL, { query: { roomId, authToken: token, clientType }, transports: ['websocket'] });

      socket.on('connect_error', (e) => { console.error('[socket connect_error]', e?.message || e); toast('Errore di connessione'); });

      uiRoomId.textContent = roomId;
      uiClientType.textContent = clientType;
      setStatus(true, 'Connessione…');

      const { canJoinRoom, existingProducers } = await joinRoom(roomId, clientType, token);
      if (!canJoinRoom) {
        setStatus(false, 'Accesso negato');
        toast('Accesso alla room negato');
        socket?.disconnect();
        return;
      }

      const routerRtpCapabilities = await getRouterCapabilities();
      device = new Device();
      await device.load({ routerRtpCapabilities });

      if (!device.canProduce('audio') && !device.canProduce('video')) {
        toast('Questo device non può produrre audio o video.');
        return;
      }

      // Media locale
      localStream = await buildLocalStream();

      // Trasporti
      sendTransport = await createTransport('send');
      setupTransportListeners(sendTransport, 'send');
      sendTransport.on('connectionstatechange', (state) => { console.log('[sendTransport] state', state); uiStatus.textContent = `Send: ${state}`; });

      recvTransport = await createTransport('recv');
      setupTransportListeners(recvTransport, 'recv');
      recvTransport.on('connectionstatechange', (state) => { console.log('[recvTransport] state', state); uiStatus.textContent = `Recv: ${state}`; });

      // Produce
      await produceTracks();

      // Producer già presenti
      for (const p of (existingProducers || [])) {
        const prodId = p.producerId ?? p;
        await subscribeToProducer(prodId, p?.appData?.socketId);
      }

      // Nuovi producer
      socket.on('newProducer', ({ producerId }) => {
        subscribeToProducer(producerId);
      });

      socket.on('hangup', hangupCall);
      socket.on('connect', () => setStatus(true, 'Connesso'));
      socket.on('disconnect', () => setStatus(false, 'Disconnesso'));

      // UI
      prejoinBackdrop.style.display = 'none';
      // Prova a forzare la riproduzione del remoto subito dopo un gesto utente
      ensurePlayback(remoteVideoElem);
      toast('Videochiamata avviata');
    }

    function setStatus(connected, label) {
      statusDot.style.background = connected ? 'var(--ok)' : 'var(--danger)';
      uiStatus.textContent = label || (connected ? 'Connesso' : 'Disconnesso');
    }

    function toast(msg, ms = 1800) {
      snackbar.textContent = msg;
      snackbar.classList.add('show');
      setTimeout(() => snackbar.classList.remove('show'), ms);
    }

    async function toggleMic() {
      const track = localStream?.getAudioTracks?.()[0];
      if (!track) return;
      track.enabled = !track.enabled;
      btnMic.setAttribute('aria-pressed', String(track.enabled));
      document.getElementById('micBadgeLocal').hidden = track.enabled;
      document.getElementById('icMic').textContent = track.enabled ? 'mic' : 'mic_off';
      toast(track.enabled ? 'Microfono attivato' : 'Microfono disattivato');
      try {
        if (audioProducer) track.enabled ? await audioProducer.resume() : await audioProducer.pause();
      } catch {}
    }

    async function toggleCam() {
      const track = localStream?.getVideoTracks?.()[0];
      if (!track) return;
      track.enabled = !track.enabled;
      btnCam.setAttribute('aria-pressed', String(track.enabled));
      document.getElementById('icCam').textContent = track.enabled ? 'videocam' : 'videocam_off';
      toast(track.enabled ? 'Fotocamera attivata' : 'Fotocamera disattivata');
      try {
        if (videoProducer) track.enabled ? await videoProducer.resume() : await videoProducer.pause();
      } catch {}
    }

    async function switchCamera(nextId) {
      const videos = await enumerateCameras();
      if (!videos.length) return;

      let idx = videos.findIndex(v => v.deviceId === (nextId || currentVideoDeviceId));
      idx = (idx + 1) % videos.length;
      const newId = videos[idx].deviceId;

      // Update preview (pre-join) and live (in-call)
      await updatePreview(newId);

      if (sendTransport) {
        const newStream = await getUserMediaFor(newId, false);
        const newTrack = newStream.getVideoTracks()[0];
        if (videoProducer) await videoProducer.replaceTrack({ track: newTrack });
        // stop old local video track
        localStream.getVideoTracks().forEach(t => t.stop());
        localStream.removeTrack(localStream.getVideoTracks()[0]);
        localStream.addTrack(newTrack);
        // update local preview element
        localVideoElem.srcObject = new MediaStream([newTrack]);
        setMirror(localVideoElem, isRearFromTrackOrLabel(newTrack, newId));
      }

      currentVideoDeviceId = newId;
      videoSourceSelect.value = newId;
      videoSourceSelect2.value = newId;
      toast('Fotocamera cambiata');
    }

    function hangupCall() {
      try {
        if (audioProducer) { audioProducer.close(); audioProducer = null; }
        if (videoProducer) { videoProducer.close(); videoProducer = null; }
        if (sendTransport) { sendTransport.close(); sendTransport = null; }
        if (recvTransport) { recvTransport.close(); recvTransport = null; }
        if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
        if (socket) { socket.disconnect(); socket = null; }
        localVideoElem.srcObject = null;
        remoteVideoElem.srcObject = null;
        setStatus(false, 'Terminata');
        prejoinBackdrop.style.display = 'grid';
        updatePreview(currentVideoDeviceId);
        toast('Chiamata terminata');
      } catch (e) {
        console.error("Errore in hangup:", e);
      }
    }

    // --- Event wiring
    joinForm.addEventListener('submit', (e) => {
      e.preventDefault();
      startCall().catch(err => { console.error(err); toast(err.message || 'Errore avvio'); });
    });

    togglePreviewCamBtn.addEventListener('click', () => {
      const t = prejoinPreview.srcObject?.getVideoTracks?.()[0];
      if (!t) return;
      t.enabled = !t.enabled;
      togglePreviewCamBtn.innerHTML = `<span class="material-symbols-rounded">${t.enabled ? 'videocam_off' : 'videocam'}</span> ${t.enabled ? 'Disattiva cam' : 'Attiva cam'}`;
    });

    btnMic.addEventListener('click', () => toggleMic());
    btnCam.addEventListener('click', () => toggleCam());
    btnSwitchCam.addEventListener('click', () => switchCamera());
    btnHangup.addEventListener('click', () => { socket?.emit?.('hangup'); hangupCall(); });
    btnUnmute.addEventListener('click', () => ensurePlayback(remoteVideoElem));

    const openSettingsHandler = () => settingsDlg.showModal();
    btnSettings.addEventListener('click', openSettingsHandler);
    openSettings.addEventListener('click', openSettingsHandler);

    videoSourceSelect.addEventListener('change', async () => {
      currentVideoDeviceId = videoSourceSelect.value;
      await updatePreview(currentVideoDeviceId);
    });

    videoSourceSelect2.addEventListener('change', async () => {
      currentVideoDeviceId = videoSourceSelect2.value;
      if (sendTransport) await switchCamera(currentVideoDeviceId); else await updatePreview(currentVideoDeviceId);
    });

    qualitySelect.addEventListener('change', async () => {
      const [w, h] = qualitySelect.value.split('x').map(n => parseInt(n, 10));
      desiredWidth = w; desiredHeight = h;
      await updatePreview(currentVideoDeviceId);
      if (sendTransport) {
        const newStream = await getUserMediaFor(currentVideoDeviceId, false);
        const newTrack = newStream.getVideoTracks()[0];
        if (videoProducer) await videoProducer.replaceTrack({ track: newTrack });
        localStream.getVideoTracks().forEach(t => t.stop());
        localStream = new MediaStream([newTrack, ...(localStream.getAudioTracks() || [])]);
        localVideoElem.srcObject = new MediaStream([newTrack]);
        setMirror(localVideoElem, isRearFromTrackOrLabel(newTrack, currentVideoDeviceId));
        toast('Qualità video aggiornata');
      }
    });

    // --- UX boot
    window.addEventListener('load', async () => {
      // URL params
      const q = new URLSearchParams(location.search);
      if (q.get('roomId')) roomIdInput.value = q.get('roomId');
      if (q.get('clientType')) clientTypeInput.value = q.get('clientType');
      if (q.get('token')) tokenInput.value = q.get('token');
      remoteLabel.textContent = clientTypeInput.value === 'host' ? 'Guest' : 'Host';

      try {
        // Get preliminary permission for accurate device labels
        const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        tmp.getTracks().forEach(t => t.stop());
      } catch (err) {
        console.warn('Permessi media non concessi in anticipo (verranno richiesti al click).', err);
      }
      await enumerateCameras();
      currentVideoDeviceId = videoSourceSelect.value;
      await updatePreview(currentVideoDeviceId);
    });
  </script>
</body>

</html>
